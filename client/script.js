import bot from './assets/bot.svg';
import user from './assets/user.svg';

const form = document.querySelector('form');
//  for form we have use query selector and tag name form 

const chatContainer = document.querySelector('#chat_container');
// here we have used id chat_container with #
//  now create a varaible
let loadInterval;

// now create a function to load our messages that will take an element which will return  3 dots(...) till the answer is not loaded these dots will show

function loader(element){
  element.textContent='';
  // this is done to ensure that the string is empty at the start

  loadInterval = setInterval(()=>{
    element.textContent+='.';
    // here we are adding a dot element to the text content now if the loading parameter has reached to .... then we want to reset the element.textcontent to an empty string
    if( element.textContent==='....'){
      element.textContent = '';

    }
  },300)
}

// now we want that the AI should giver answer step by step as in it shows that it is thinking so we  will create a function that will accept element an dtext as parameters

function typeText(element,text){
  let index= 0;

  let interval = setInterval(()=>{
// inside layer we will check if the index is less than text.length and if it is that means we are still typing so if we are still typing we can set the inner html to 
if(index < text.length) {
  element.innerHTML += text.charAt(index);
  index++;
    
  // this will get the character in a specific index in text that Ai isd going to return
    } 
    else{
      clearInterval(interval);
    }
  },20)
}

// now we can type text and load AI answers

// now we will generate a unique ID for every single message

function generateUniqueId(){
  // in many programming langs  a unique id is generated by using current time and date , to make it it even more random we will get another random number, finally we can make it even more random by creating a hexa decimal string, finally we are gonna return an id of template string timestamp and hexadecimal number
  const timestamp = Date.now();
  const randomNumber= Math.random();
  const hexadecimalString = randomNumber.toString(16);

  return `id-${timestamp}-${hexadecimalString}`;
}

// isAi is is AI speaking or us
function chatStripe (isAi,value, uniqueId){
  return(
    `
    <div class="wrapper ${isAi && 'ai'}">
      <div class="chat">
        <div class="profile">
          <img
          src="${isAi ? bot : user }"
          alt="${isAi ? 'bot' : 'user' }"
          />
        </div>
          <div class="message" id=${uniqueId}>${value}></div>
      </div>
    </div>
    `
  )
}
// this will be the trigger to get the ai generated response it, handleSubmit will take an event , we will use e.preventdefault so that thye browser doesn't reload(it will prevent the default behaviour of the browser), now we want bto get the data that we tytped into the form, this form is the form element that we have provided earlier, then we want to generate a new chat stripe
const handleSubmit = async(e) =>{
e.preventDefault();

const data = new FormData(form)

// genearte the user's chatstripe, we pass false in the chatstripe as its not ai and its us, clear the textaarea input by form.reset()
chatContainer.innerHTML += chatStripe(false,data.get('prompt'));

form.reset();

// now this is the bot's chatstripe, create a unique id for its msg, as we created chatstripe for us we also want it to generate for AI, this time the meassage will be tyrue as AI is typing
const uniqueId = generateUniqueId();

chatContainer.innerHTML += chatStripe(true,"", uniqueId)

// as the user is typing so we want to keep scrolling down to be able to see that meassage

chatContainer.scrollTop = chatContainer.scrollHeight;
// now we want to fetch this newly created div, we need to create uniqueId for every meassage

const meassageDiv = document.getElementById(uniqueId);
loader(meassageDiv);
//  fetch data from server that is bots response
const response = await fetch('http://localhost:5000',{
  method:'POST',
  headers:{
    'Content-type':'application/json'
  },
  body:JSON.stringify({
    prompt:data.get('prompt')
  })
})
// beacuse we are not longer loading
clearInterval(loadInterval)
// because we are not sure at which point of loading we are
meassageDiv.innerHTML = '';

if(response.ok){
  // this will give the actual response coming from the backend
  const data = await response.json();
  const parsedData = data.bot.trim();
  typeText(meassageDiv,parsedData);

} else{
  const err = await response.text();
  meassageDiv.innerHTML = "something went wrong";
  alert(err);
}
}

// to be able to see the changes we have made to our handle submit we need to be able to see it

form.addEventListener('submit',handleSubmit);
// since we are devs so we have a habit of pressing eneter and submitting things so here we will also make an eventlistener for enter key, keyup means once a key is pressed and released upwards, keycode 13 is the enter key
form.addEventListener('keyup',(e)=>{
  if(e.keyCode === 13){
    handleSubmit(e)
  }
})